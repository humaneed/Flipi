<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="theme-color" content="#4A7C91" />
  <title>Kidsneed ‚Äì Sticker Pinball (Improved)</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@600;800;900&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#F5F0E8;
      --card:#FFFFFF;
      --muted:#EDE8DC;

      --ink:#2D2A26;
      --ink2:#6B665C;

      --accent:#4A7C91;
      --mint:#7BA08A;
      --sun:#E8C547;
      --coral:#E07A5F;
      --violet:#7B6EA8;

      --r-lg:24px;
      --shadow:0 8px 24px rgba(45,42,38,.12);
      --shadow2:0 2px 10px rgba(45,42,38,.10);

      --s2:12px; --s3:16px; --s4:24px;
      --maxw:560px;
    }

    *{box-sizing:border-box; -webkit-tap-highlight-color:transparent;}
    html,body{height:100%;}
    body{
      margin:0;
      background:var(--bg);
      font-family:Nunito, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:var(--ink);
      overscroll-behavior:none;
      touch-action:none;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:calc(env(safe-area-inset-top) + var(--s3)) var(--s3) calc(env(safe-area-inset-bottom) + var(--s3));
    }

    .frame{
      width:100%;
      max-width:var(--maxw);
      height:min(92dvh, 920px);
      background:var(--card);
      border:3px solid var(--ink);
      border-radius:var(--r-lg);
      box-shadow:var(--shadow2);
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }

    .topbar{
      height:84px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:var(--s2);
      padding:0 var(--s3);
      border-bottom:3px solid var(--ink);
      background:linear-gradient(180deg, rgba(255,255,255,1), rgba(237,232,220,.55));
    }

    .title{display:flex; flex-direction:column; gap:6px; min-width:0;}
    .title b{
      font-size:18px; font-weight:900; letter-spacing:-.02em;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .title small{
      font-weight:900; font-size:12px; letter-spacing:.10em;
      color:var(--ink2); text-transform:uppercase;
    }

    .progress{
      width:200px;
      max-width:32vw;
      height:12px;
      border:2px solid var(--ink);
      border-radius:999px;
      background:rgba(237,232,220,.8);
      overflow:hidden;
      box-shadow:0 1px 0 rgba(0,0,0,.06) inset;
    }
    .progress > i{
      display:block;
      height:100%;
      width:0%;
      background:var(--sun);
      border-right:2px solid rgba(45,42,38,.25);
      transition:width .18s ease;
    }

    .chips{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;
    }

    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:10px 12px;
      border-radius:999px;
      border:2px solid var(--ink);
      background:var(--muted);
      font-weight:900;
      user-select:none;
      white-space:nowrap;
    }
    .pill span{
      color:var(--ink2); font-weight:900; font-size:12px; letter-spacing:.10em; text-transform:uppercase;
    }
    .pill b{font-size:14px;}

    .btn{
      border:2px solid var(--ink);
      background:var(--muted);
      border-radius:12px;
      padding:10px 12px;
      font-weight:900;
      cursor:pointer;
      user-select:none;
    }
    .btn:active{transform:translateY(1px);}

    .stage{
      position:relative;
      flex:1;
      padding:var(--s3);
      background:
        radial-gradient(900px 340px at 50% 0%, rgba(74,124,145,.12), transparent 60%),
        var(--card);
    }

    .board{
      position:absolute;
      inset:var(--s3);
      border-radius:var(--r-lg);
      border:3px solid var(--ink);
      box-shadow:var(--shadow);
      overflow:hidden;
      background: linear-gradient(180deg, rgba(237,232,220,.65), rgba(255,255,255,1));
    }

    canvas{width:100%; height:100%; display:block;}

    /* Touch zones: links/rechts halten */
    .zones{position:absolute; inset:0; display:flex;}
    .zone{flex:1; background:transparent; touch-action:none; position:relative;}
    .zoneHint{
      position:absolute;
      bottom:14px;
      left:14px;
      right:14px;
      padding:10px 12px;
      border-radius:16px;
      border:2px dashed rgba(45,42,38,.14);
      background:rgba(237,232,220,.50);
      color:rgba(107,102,92,.92);
      font-weight:900;
      font-size:12px;
      letter-spacing:.04em;
      text-transform:uppercase;
      opacity:.0;
      transition:opacity .2s ease;
      pointer-events:none;
    }
    .zone.right .zoneHint{left:14px; right:14px;}
    .showHints .zoneHint{opacity:.85;}

    .toast{
      position:absolute;
      left:50%; top:14px;
      transform:translateX(-50%) translateY(-6px);
      padding:10px 14px;
      border-radius:999px;
      background:rgba(45,42,38,.92);
      color:#fff;
      font-weight:900;
      opacity:0;
      transition:opacity .16s ease, transform .16s ease;
      pointer-events:none;
      box-shadow:0 10px 30px rgba(0,0,0,.18);
      white-space:nowrap;
    }
    .toast.show{opacity:1; transform:translateX(-50%) translateY(0);}

    .overlay{
      position:absolute; inset:0;
      display:none; align-items:center; justify-content:center;
      background:rgba(245,240,232,.72);
      backdrop-filter:blur(6px);
      padding:var(--s3);
    }
    .panel{
      width:min(460px, 100%);
      background:var(--card);
      border:3px solid var(--ink);
      border-radius:var(--r-lg);
      box-shadow:var(--shadow);
      padding:var(--s4);
    }
    .panel h2{margin:0 0 var(--s2); font-size:20px; font-weight:900;}
    .panel p{margin:0 0 var(--s3); color:var(--ink2); font-weight:800; line-height:1.38;}
    .panel .row{display:flex; gap:var(--s2); justify-content:space-between; flex-wrap:wrap;}
    .hint{
      margin-top:12px;
      padding:10px 12px;
      border-radius:16px;
      border:2px dashed rgba(45,42,38,.18);
      background:rgba(237,232,220,.55);
      color:var(--ink2);
      font-weight:900;
      font-size:13px;
    }
  </style>
</head>

<body>
  <div class="frame">
    <div class="topbar">
      <div class="title">
        <b>Sticker-Pinball</b>
        <small>Kinder-Flipper ¬∑ verbessert</small>
        <div class="progress" title="Sterne sammeln">
          <i id="pbar"></i>
        </div>
      </div>

      <div class="chips">
        <div class="pill" title="Sterne">
          <span>‚≠ê</span><b id="stars">0</b><span>/</span><b id="goal">15</b>
        </div>
        <div class="pill" title="Kickback (1√ó pro Ball)">
          <span>üõü</span><b id="kick">an</b>
        </div>
        <div class="pill" title="Bonus">
          <span>Bonus</span><b id="bonus">0</b>
        </div>
        <div class="pill" title="B√§lle">
          <span>‚ù§</span><b id="lives">3</b>
        </div>
        <div class="pill" title="Best">
          <span>Best</span><b id="best">0</b>
        </div>
        <div class="pill" title="Score">
          <span>Score</span><b id="score">0</b>
        </div>
        <button class="btn" id="btnPause" title="Pause">‚è∏</button>
        <button class="btn" id="btnReset" title="Neu">‚Üª</button>
      </div>
    </div>

    <div class="stage">
      <div class="board" id="board">
        <canvas id="cv"></canvas>
        <div class="toast" id="toast">Los geht‚Äôs!</div>

        <div class="zones showHints" id="zones" aria-hidden="true">
          <div class="zone left" id="zl">
            <div class="zoneHint">Links halten ¬∑ Flipper</div>
          </div>
          <div class="zone right" id="zr">
            <div class="zoneHint">Rechts halten ¬∑ Flipper/Plunger</div>
          </div>
        </div>

        <div class="overlay" id="over">
          <div class="panel">
            <h2 id="overTitle">Pause</h2>
            <p id="overText">
              Steuerung:<br>
              <b>Links halten</b> = linker Flipper ¬∑ <b>Rechts halten</b> = rechter Flipper / Plunger laden.<br>
              Wenn der Ball im Plunger ist: <b>rechts halten</b> (laden) ‚Üí <b>loslassen</b> (schie√üen).<br><br>
              Tipp: Oben die 3 Rollovers einsammeln ‚Üí mehr Sterne!
            </p>
            <div class="row">
              <button class="btn" id="overResume">Weiter</button>
              <button class="btn" id="overSound">Sound: An</button>
              <button class="btn" id="overEasy">Easy: An</button>
              <button class="btn" id="overHints">Hints: Aus</button>
            </div>
            <div class="hint">
              Ziel: Sammle ‚≠ê Sterne. Bei Ziel erreicht: <b>Sticker-Feuerwerk</b> + Bonus.
              Kickback üõü rettet dich 1√ó pro Ball (Easy: √∂fter Bonus m√∂glich).
            </div>
          </div>
        </div>

      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  // ===== Settings (ruhig, fair, stabil) =====
  const CFG = {
    tableW: 400,
    tableH: 700,

    // physics
    ballR: 9,
    gravity: 1180,
    damping: 0.996,
    maxSpeed: 1550,

    wallRest: 0.93,
    bumperRest: 1.05,
    slingRest: 1.07,
    flipperRest: 0.90,

    // flippers
    flLen: 78,
    flWidth: 14,
    flRestAngle: 0.50,
    flUpAngle: -0.72,
    flSnap: 24,
    flPunch: 220,

    // plunger
    plungerMax: 1350,
    plCharge: 1100,
    plMin: 120,

    // kid-friendly pacing
    lives: 3,
    ballSave: 1.6,     // forgiving
    easyMode: true,    // default ON

    // mission
    starGoalBase: 15,
    starGoalStep: 2,
    starGoalCap: 25,

    // scoring
    hitScore: 8,
    bumperScore: 40,
    slingScore: 10,
    rolloverScore: 60,
    stickerBonusBase: 320,

    // targets
    targetRespawn: 2.0,     // seconds
    rolloverCooldown: 0.8,

    // confetti
    confettiCount: 20,

    // kickback
    kickbackVy: -980,
    kickbackVx: 0,

    // stability
    stepHz: 120,
    maxFrameDt: 0.05,
  };

  // DOM
  const cv = document.getElementById("cv");
  const boardEl = document.getElementById("board");
  const zonesEl = document.getElementById("zones");
  const ctx = cv.getContext("2d");

  const elStars = document.getElementById("stars");
  const elGoal  = document.getElementById("goal");
  const elBonus = document.getElementById("bonus");
  const elLives = document.getElementById("lives");
  const elScore = document.getElementById("score");
  const elBest  = document.getElementById("best");
  const elKick  = document.getElementById("kick");
  const pbar    = document.getElementById("pbar");
  const toast   = document.getElementById("toast");

  const btnReset = document.getElementById("btnReset");
  const btnPause = document.getElementById("btnPause");

  const over = document.getElementById("over");
  const overTitle = document.getElementById("overTitle");
  const overResume = document.getElementById("overResume");
  const overSound = document.getElementById("overSound");
  const overEasy = document.getElementById("overEasy");
  const overHints = document.getElementById("overHints");

  const zl = document.getElementById("zl");
  const zr = document.getElementById("zr");

  // helpers
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const hypot = (x,y)=>Math.sqrt(x*x+y*y);

  function showToast(txt){
    toast.textContent = txt;
    toast.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toast.classList.remove("show"), 650);
  }

  // ===== Responsive fit =====
  let DPR = 1, scale = 1, offX = 0, offY = 0, pxW = 0, pxH = 0;
  function resize(){
    const r = boardEl.getBoundingClientRect();
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    pxW = Math.floor(r.width * DPR);
    pxH = Math.floor(r.height * DPR);
    cv.width = pxW;
    cv.height = pxH;

    const sx = pxW / CFG.tableW;
    const sy = pxH / CFG.tableH;
    scale = Math.min(sx, sy);

    offX = (pxW - CFG.tableW * scale) * 0.5;
    offY = (pxH - CFG.tableH * scale) * 0.5;

    ctx.setTransform(1,0,0,1,0,0);
  }
  window.addEventListener("resize", resize, {passive:true});
  resize();

  // ===== Minimal sound =====
  let audioCtx=null;
  let soundOn=true;
  function beep(freq=520, dur=0.06, gain=0.035, type="sine"){
    if(!soundOn) return;
    try{
      if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      const t0 = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t0);
      g.gain.setValueAtTime(gain, t0);
      g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
      o.connect(g); g.connect(audioCtx.destination);
      o.start(t0); o.stop(t0+dur);
    }catch(e){}
  }

  // ===== localStorage best score =====
  const BEST_KEY = "kidsneed_pinball_best_v1";
  function loadBest(){
    const v = Number(localStorage.getItem(BEST_KEY) || "0");
    return Number.isFinite(v) ? v : 0;
  }
  function saveBest(v){
    try{ localStorage.setItem(BEST_KEY, String(v|0)); }catch(e){}
  }

  function updateOverlayButtons(){
    overSound.textContent = "Sound: " + (soundOn ? "An" : "Aus");
    overEasy.textContent  = "Easy: "  + (CFG.easyMode ? "An" : "Aus");
    overHints.textContent = "Hints: " + (zonesEl.classList.contains("showHints") ? "Aus" : "An");
  }

  // ===== Geometry =====
  let walls=[], slings=[], bumpers=[], targets=[], rollovers=[], gate=[];
  function seg(x1,y1,x2,y2){ return {x1,y1,x2,y2}; }
  function circ(x,y,r, kind, data){ return {x,y,r, kind, data, glow:0, cd:0}; }

  function buildTable(){
    const W=CFG.tableW, H=CFG.tableH;
    walls=[]; slings=[]; bumpers=[]; targets=[]; rollovers=[]; gate=[];

    const pad=12;
    const left=pad, right=W-pad, top=pad, bot=H-pad;

    // drain gap
    const drainGap = 140;
    const mid = W/2;

    // outer boundaries
    walls.push(
      seg(left, top, right, top),
      seg(left, top, left, bot-190),
      seg(right, top, right, bot-190),
      seg(left, bot-190, mid - drainGap/2, bot),
      seg(mid + drainGap/2, bot, right, bot-190),
    );

    // plunger lane (open exit + guide)
    const plA = W*0.80;
    const plB = W*0.92;
    walls.push(seg(plB, bot, plB, H*0.10));
    walls.push(seg(plA, bot, plA, H*0.42));
    walls.push(seg(W*0.16, H*0.14, W*0.72, H*0.14));
    walls.push(seg(plA, H*0.42, W*0.64, H*0.30));

    // gentle ramps
    walls.push(
      seg(W*0.18, H*0.48, W*0.40, H*0.58),
      seg(W*0.82, H*0.48, W*0.60, H*0.58),
    );

    // slings
    slings.push(
      seg(W*0.20, H*0.70, W*0.34, H*0.80),
      seg(W*0.34, H*0.80, W*0.24, H*0.86),
      seg(W*0.24, H*0.86, W*0.20, H*0.70),

      seg(W*0.80, H*0.70, W*0.66, H*0.80),
      seg(W*0.66, H*0.80, W*0.76, H*0.86),
      seg(W*0.76, H*0.86, W*0.80, H*0.70),
    );

    // bumpers as ‚ÄúSticker-Tiere‚Äù (mehr Variation)
    bumpers.push(
      circ(W*0.40, H*0.20, 24, "bumper", {emoji:"üêª", color:"#7BA08A", stars:1}),
      circ(W*0.60, H*0.20, 24, "bumper", {emoji:"üê∏", color:"#4A7C91", stars:1}),
      circ(W*0.50, H*0.31, 30, "bumper", {emoji:"ü¶ä", color:"#E07A5F", stars:2}),
      circ(W*0.30, H*0.28, 18, "bumper", {emoji:"üê≥", color:"#7B6EA8", stars:1}),
      circ(W*0.70, H*0.28, 18, "bumper", {emoji:"ü¶ã", color:"#E8C547", stars:1}),
    );

    // targets (respawn)
    targets.push(
      circ(W*0.30, H*0.52, 13, "target", {emoji:"‚≠ê", color:"#E8C547", stars:1}),
      circ(W*0.70, H*0.52, 13, "target", {emoji:"‚≠ê", color:"#E8C547", stars:1}),
      circ(W*0.50, H*0.62, 13, "target", {emoji:"‚≠ê", color:"#E8C547", stars:1}),
      circ(W*0.22, H*0.58, 11, "target", {emoji:"‚ú®", color:"#E8C547", stars:1}),
      circ(W*0.78, H*0.58, 11, "target", {emoji:"‚ú®", color:"#E8C547", stars:1}),
    );

    // rollovers (oben): wenn alle 3 -> extra Sterne + Bonus
    rollovers.push(
      circ(W*0.22, H*0.10, 10, "roll", {color:"#7BA08A", hit:false, t:0}),
      circ(W*0.50, H*0.10, 10, "roll", {color:"#4A7C91", hit:false, t:0}),
      circ(W*0.78, H*0.10, 10, "roll", {color:"#E07A5F", hit:false, t:0}),
    );

    // gate (bonus lane) with cooldown
    gate.push(circ(W*0.86, H*0.18, 14, "gate", {emoji:"üåà", color:"#7B6EA8", stars:3, t:0, cd:0.9}));
  }

  // ===== Collision helpers =====
  function closestPoint(px,py, x1,y1,x2,y2){
    const dx=x2-x1, dy=y2-y1;
    const l2 = dx*dx+dy*dy || 1;
    let t = ((px-x1)*dx + (py-y1)*dy)/l2;
    t = clamp(t,0,1);
    return { x:x1+t*dx, y:y1+t*dy };
  }

  function reflect(ball, nx, ny, rest){
    const dot = ball.vx*nx + ball.vy*ny;
    if(dot < 0){
      ball.vx = (ball.vx - 2*dot*nx) * rest;
      ball.vy = (ball.vy - 2*dot*ny) * rest;
    }
  }

  function collideSegment(ball, s, rest, boost=1){
    const cp = closestPoint(ball.x,ball.y, s.x1,s.y1,s.x2,s.y2);
    const dx = ball.x - cp.x, dy = ball.y - cp.y;
    const dist = Math.sqrt(dx*dx+dy*dy) || 0.0001;
    const overlap = ball.r - dist;
    if(overlap > 0){
      const nx = dx/dist, ny = dy/dist;
      ball.x += nx*(overlap+0.55);
      ball.y += ny*(overlap+0.55);
      reflect(ball, nx, ny, rest);
      ball.vx *= boost; ball.vy *= boost;
      return true;
    }
    return false;
  }

  function collideCircle(ball, c, rest, kick=55){
    const dx=ball.x-c.x, dy=ball.y-c.y;
    const dist = Math.sqrt(dx*dx+dy*dy) || 0.0001;
    const minD = ball.r + c.r;
    if(dist < minD){
      const nx = dx/dist, ny = dy/dist;
      const overlap = minD - dist;
      ball.x += nx*(overlap+0.7);
      ball.y += ny*(overlap+0.7);
      reflect(ball, nx, ny, rest);
      ball.vx += nx*kick;
      ball.vy += ny*kick;
      return true;
    }
    return false;
  }

  // ===== State =====
  const ball = { x:0, y:0, vx:0, vy:0, r:CFG.ballR, inPlunger:true, saveT:0 };
  let plPower=0;

  const flL = { side:"L", px:120, py:CFG.tableH-60, len:CFG.flLen, ang:0, targ:0, av:0 };
  const flR = { side:"R", px:CFG.tableW-170, py:CFG.tableH-60, len:CFG.flLen, ang:0, targ:0, av:0 };

  let holdL=false, holdR=false, prevHoldR=false;

  let score=0, lives=CFG.lives;
  let stars=0, bonus=0;
  let best=loadBest();
  let paused=false;

  let confetti=[];
  let kickbackReady=true;

  function goalNow(){
    return clamp(CFG.starGoalBase + bonus*CFG.starGoalStep, CFG.starGoalBase, CFG.starGoalCap);
  }

  function resetBall(){
    ball.x = CFG.tableW-25;
    ball.y = CFG.tableH-55;
    ball.vx = 0; ball.vy = 0;
    ball.inPlunger = true;
    ball.saveT = 0;
    plPower = 0;

    // per-ball helper
    kickbackReady = CFG.easyMode ? true : true;
    rollovers.forEach(r => { r.data.hit=false; r.data.t=0; });

    updateHUD();
  }

  function resetGame(){
    buildTable();
    score=0; lives=CFG.lives;
    stars=0; bonus=0;
    confetti.length=0;
    best = loadBest();
    resetBall();
    showToast("‚≠ê Sammle Sterne!");
    beep(520,0.07,0.03,"sine");
  }

  function updateHUD(){
    const g = goalNow();
    elStars.textContent = String(stars);
    elGoal.textContent  = String(g);
    elBonus.textContent = String(bonus);
    elLives.textContent = String(lives);
    elScore.textContent = String(score|0);
    elBest.textContent  = String(best|0);
    elKick.textContent  = kickbackReady ? "an" : "aus";

    const pct = g>0 ? clamp((stars/g)*100, 0, 100) : 0;
    pbar.style.width = pct.toFixed(1) + "%";
  }

  function awardStars(n, label){
    stars += n;
    score += n*35 + bonus*10;

    if(label) showToast(label);

    // mission complete
    const g = goalNow();
    if(stars >= g){
      stars = 0;
      bonus = Math.min(9, bonus+1);
      score += CFG.stickerBonusBase + bonus*130;
      makeConfetti();
      showToast("üéâ Sticker-Bonus!");
      beep(760,0.08,0.05,"triangle");
      beep(920,0.07,0.045,"sine");

      if(CFG.easyMode && bonus % 3 === 0 && lives < 5){
        lives++;
        showToast("‚ù§ Extra Ball!");
        beep(660,0.08,0.05,"sine");
      }
    }

    if(score > best){
      best = score|0;
      saveBest(best);
    }
    updateHUD();
  }

  function makeConfetti(){
    confetti.length = 0;
    const colors = ["#4A7C91","#7BA08A","#E8C547","#E07A5F","#7B6EA8"];
    for(let i=0;i<CFG.confettiCount;i++){
      confetti.push({
        x: CFG.tableW*0.50 + (Math.random()*50-25),
        y: 76 + Math.random()*22,
        vx: Math.random()*240 - 120,
        vy: Math.random()*-240 - 100,
        g: 540 + Math.random()*260,
        r: 4 + Math.random()*4,
        rot: Math.random()*Math.PI*2,
        vr: Math.random()*6 - 3,
        c: colors[i % colors.length],
        t: 1.25 + Math.random()*0.7
      });
    }
  }

  // ===== Input =====
  function bindHold(el, setFn){
    el.addEventListener("pointerdown", (e)=>{ e.preventDefault(); setFn(true); }, {passive:false});
    el.addEventListener("pointerup", (e)=>{ e.preventDefault(); setFn(false); }, {passive:false});
    el.addEventListener("pointercancel", (e)=>{ e.preventDefault(); setFn(false); }, {passive:false});
    el.addEventListener("pointerleave", (e)=>{ e.preventDefault(); setFn(false); }, {passive:false});
  }
  bindHold(zl, v=>holdL=v);
  bindHold(zr, v=>holdR=v);

  window.addEventListener("keydown", (e)=>{
    if(e.repeat) return;
    if(e.key==="ArrowLeft" || e.key==="a") holdL=true;
    if(e.key==="ArrowRight" || e.key==="l") holdR=true;
    if(e.key===" ") tryLaunch();
    if(e.key==="Escape") togglePause();
  });
  window.addEventListener("keyup", (e)=>{
    if(e.key==="ArrowLeft" || e.key==="a") holdL=false;
    if(e.key==="ArrowRight" || e.key==="l") holdR=false;
  });

  // ===== Pause / Settings =====
  function togglePause(force){
    paused = (typeof force === "boolean") ? force : !paused;
    over.style.display = paused ? "flex" : "none";
    overTitle.textContent = paused ? "Pause" : " ";
    updateOverlayButtons();
  }
  btnPause.addEventListener("click", ()=>togglePause());
  overResume.addEventListener("click", ()=>togglePause(false));
  overSound.addEventListener("click", ()=>{ soundOn=!soundOn; updateOverlayButtons(); beep(420,0.05,0.03); });
  overEasy.addEventListener("click", ()=>{ CFG.easyMode=!CFG.easyMode; updateOverlayButtons(); showToast(CFG.easyMode ? "Easy an" : "Easy aus"); });
  overHints.addEventListener("click", ()=>{
    zonesEl.classList.toggle("showHints");
    updateOverlayButtons();
    showToast(zonesEl.classList.contains("showHints") ? "Hints an" : "Hints aus");
  });
  btnReset.addEventListener("click", ()=>{ togglePause(false); resetGame(); });

  // prevent iOS scroll
  document.addEventListener("touchmove", (e)=>e.preventDefault(), {passive:false});

  // auto-hide hints after a bit
  setTimeout(()=>zonesEl.classList.remove("showHints"), 4000);

  // ===== Flippers =====
  function flipperEndpoints(f){
    const x2 = f.px + Math.cos(f.ang)*f.len;
    const y2 = f.py + Math.sin(f.ang)*f.len;
    return {x1:f.px, y1:f.py, x2, y2};
  }

  function updateFlippers(dt){
    const restL = +CFG.flRestAngle;
    const upL   = CFG.flUpAngle;
    const restR = Math.PI - CFG.flRestAngle;
    const upR   = Math.PI - CFG.flUpAngle;

    flL.targ = holdL ? upL : restL;
    flR.targ = holdR ? upR : restR;

    const move = (f)=>{
      const prev = f.ang;
      f.ang += (f.targ - f.ang) * clamp(CFG.flSnap*dt,0,1);
      f.av = (f.ang - prev) / dt;
    };
    move(flL); move(flR);
  }

  // ===== Launch =====
  function tryLaunch(){
    if(!ball.inPlunger) return;
    if(plPower < CFG.plMin) return;

    ball.inPlunger = false;
    ball.vx = -55 + (Math.random()*18 - 9);
    ball.vy = -plPower;
    ball.x  = CFG.tableW * 0.78; // reliable exit
    ball.saveT = CFG.ballSave;

    plPower = 0;
    beep(520,0.06,0.03,"sine");
  }

  // ===== Draw helpers =====
  function drawStickerCircle(c, withBorder=true){
    const color = c.data?.color || "#4A7C91";
    const glow = c.glow || 0;

    // glow ring
    ctx.save();
    ctx.globalAlpha = 0.10 + 0.18*glow;
    ctx.fillStyle = color;
    ctx.beginPath(); ctx.arc(c.x,c.y,c.r+10,0,Math.PI*2); ctx.fill();
    ctx.restore();

    // sticker body (disabled -> greyed)
    const active = !c.data?.inactive;
    ctx.fillStyle = active ? "rgba(255,255,255,0.94)" : "rgba(255,255,255,0.60)";
    ctx.beginPath(); ctx.arc(c.x,c.y,c.r,0,Math.PI*2); ctx.fill();

    if(withBorder){
      ctx.lineWidth=2;
      ctx.strokeStyle="rgba(45,42,38,0.18)";
      ctx.stroke();
    }

    // emoji
    const em = c.data?.emoji || "";
    if(em){
      ctx.save();
      ctx.font = `${Math.max(14, c.r)}px system-ui, Apple Color Emoji, Segoe UI Emoji`;
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      ctx.globalAlpha = active ? 1 : 0.55;
      ctx.fillText(em, c.x, c.y+1);
      ctx.restore();
    }
  }

  function drawFlipper(f){
    const e = flipperEndpoints(f);
    ctx.lineCap="round";
    ctx.lineWidth = CFG.flWidth;
    ctx.strokeStyle="rgba(45,42,38,0.34)";
    ctx.beginPath(); ctx.moveTo(e.x1,e.y1); ctx.lineTo(e.x2,e.y2); ctx.stroke();

    ctx.lineWidth = Math.max(4, CFG.flWidth-6);
    ctx.strokeStyle="rgba(123,160,138,0.70)";
    ctx.beginPath(); ctx.moveTo(e.x1,e.y1); ctx.lineTo(e.x2,e.y2); ctx.stroke();
  }

  // ===== Fixed timestep loop =====
  let last = performance.now();
  let acc = 0;
  const STEP = 1/CFG.stepHz;

  function physicsSubstep(dt){
    if(paused) return;

    updateFlippers(dt);

    // cooldowns
    for(const r of rollovers){
      r.data.t = Math.max(0, r.data.t - dt);
    }
    for(const g of gate){
      g.data.t = Math.max(0, g.data.t - dt);
    }
    for(const t of targets){
      t.cd = Math.max(0, t.cd - dt);
      if(t.cd === 0 && t.data.inactive){
        t.data.inactive = false;
      }
    }

    // plunger: hold right to charge, release to shoot
    if(ball.inPlunger){
      ball.x = CFG.tableW - 25;
      ball.y = clamp(ball.y, CFG.tableH-95, CFG.tableH-55);

      if(holdR){
        plPower = clamp(plPower + CFG.plCharge*dt, 0, CFG.plungerMax);
      }
      if(prevHoldR && !holdR){
        tryLaunch();
      }
      prevHoldR = holdR;
      return;
    }

    // integrate
    const grav = CFG.easyMode ? (CFG.gravity*0.95) : CFG.gravity;
    ball.vy += grav * dt;
    ball.x += ball.vx * dt;
    ball.y += ball.vy * dt;

    // damping
    const damp = CFG.easyMode ? (CFG.damping*1.0005) : CFG.damping;
    ball.vx *= damp;
    ball.vy *= damp;

    // speed cap
    const sp = hypot(ball.vx,ball.vy);
    const cap = CFG.easyMode ? (CFG.maxSpeed*0.92) : CFG.maxSpeed;
    if(sp > cap){
      const s = cap/sp;
      ball.vx *= s; ball.vy *= s;
    }

    // collisions: walls
    for(const w of walls){
      if(collideSegment(ball, w, CFG.wallRest, 1)) {
        score += CFG.hitScore + Math.min(20, bonus*2);
      }
    }

    // slings
    for(const s of slings){
      if(collideSegment(ball, s, CFG.slingRest, 1.01)){
        score += CFG.slingScore;
        beep(420,0.04,0.018,"triangle");
      }
    }

    // flippers + gentle punch when pressed
    for(const f of [flL, flR]){
      const e = flipperEndpoints(f);
      const hit = collideSegment(ball, {x1:e.x1,y1:e.y1,x2:e.x2,y2:e.y2}, CFG.flipperRest, 1);
      if(hit){
        const pressing = (f.side==="L" && holdL) || (f.side==="R" && holdR);
        if(pressing){
          const punch = CFG.easyMode ? (CFG.flPunch*0.85) : CFG.flPunch;
          ball.vx += Math.cos(f.ang) * punch;
          ball.vy += Math.sin(f.ang) * punch;
        }
        beep(520,0.035,0.012,"sine");
      }
    }

    // bumpers
    for(const b of bumpers){
      if(collideCircle(ball, b, CFG.bumperRest, CFG.easyMode ? 52 : 68)){
        b.glow = 1;
        score += CFG.bumperScore + bonus*6;
        awardStars(b.data.stars, `${b.data.emoji} +${b.data.stars}`);
        beep(660,0.06,0.03,"sine");
      }
      b.glow = Math.max(0, b.glow - 3*dt);
    }

    // targets (respawn): only if active
    for(const t of targets){
      if(t.data.inactive) continue;
      if(collideCircle(ball, t, 1.02, 40)){
        t.glow = 1;
        t.data.inactive = true;
        t.cd = CFG.targetRespawn;
        awardStars(t.data.stars, `${t.data.emoji} +${t.data.stars}`);
        score += 30 + bonus*10;
        beep(740,0.05,0.022,"triangle");
      }
      t.glow = Math.max(0, t.glow - 4*dt);
    }

    // rollovers: top lanes
    for(const r of rollovers){
      if(r.data.t > 0) continue;
      const dx=ball.x-r.x, dy=ball.y-r.y;
      const rr=(ball.r+r.r);
      if(dx*dx+dy*dy <= rr*rr){
        r.data.t = CFG.rolloverCooldown;
        if(!r.data.hit){
          r.data.hit = true;
          awardStars(1, "Rollover +1");
          score += CFG.rolloverScore + bonus*15;
          beep(820,0.05,0.02,"sine");

          // all 3 -> extra
          if(rollovers.every(x=>x.data.hit)){
            rollovers.forEach(x=>x.data.hit=false);
            awardStars(3, "üéØ Alle Rollovers!");
            score += 240 + bonus*40;
            makeConfetti();
            beep(920,0.06,0.03,"triangle");
          }
        } else {
          score += 10;
        }
      }
    }

    // gate: cooldown
    for(const g of gate){
      if(g.data.t > 0) continue;
      const dx=ball.x-g.x, dy=ball.y-g.y;
      const rr=(ball.r+g.r);
      if(dx*dx+dy*dy <= rr*rr){
        g.data.t = g.data.cd;
        g.glow = 1;
        awardStars(g.data.stars, `${g.data.emoji} +${g.data.stars}`);
        score += 120 + bonus*20;
        beep(860,0.07,0.03,"sine");
      }
      g.glow = Math.max(0, g.glow - 3*dt);
    }

    // ball save
    if(ball.saveT > 0) ball.saveT = Math.max(0, ball.saveT - dt);

    // kickback zone: left outlane rescue (1√ó pro ball)
    // (simple & robust: region check near bottom left side)
    if(kickbackReady && ball.y > CFG.tableH-170 && ball.x < (CFG.tableW*0.26)){
      kickbackReady = false;
      ball.x = CFG.tableW*0.30;
      ball.y = CFG.tableH*0.78;
      ball.vx = CFG.kickbackVx;
      ball.vy = CFG.kickbackVy * (CFG.easyMode ? 1.0 : 0.92);
      ball.saveT = Math.max(ball.saveT, 0.7);
      showToast("üõü Kickback!");
      beep(520,0.06,0.03,"triangle");
      updateHUD();
    }

    // drain
    if(ball.y > CFG.tableH + 55){
      if(ball.saveT > 0){
        resetBall();
        showToast("üõü Ball Save!");
        beep(520,0.06,0.03,"sine");
        return;
      }

      lives--;
      if(lives > 0){
        resetBall();
        showToast("‚ù§ Weiter!");
        beep(220,0.08,0.03,"triangle");
      } else {
        paused = true;
        over.style.display = "flex";
        overTitle.textContent = "Spiel vorbei";
        showToast("Spiel vorbei");
      }
      updateHUD();
      return;
    }

    // confetti physics
    if(confetti.length){
      for(const p of confetti){
        p.vy += p.g*dt;
        p.x += p.vx*dt;
        p.y += p.vy*dt;
        p.rot += p.vr*dt;
        p.t -= dt;
      }
      confetti = confetti.filter(p => p.t > 0 && p.y < CFG.tableH+80);
    }

    // best score
    if(score > best){
      best = score|0;
      saveBest(best);
    }
    updateHUD();
  }

  function physicsStep(dt){
    // dynamic substeps when fast -> fewer tunneling/sticking issues
    const sp = hypot(ball.vx, ball.vy);
    const n = sp > 1050 ? 2 : 1;
    const sub = dt / n;
    for(let i=0;i<n;i++) physicsSubstep(sub);
  }

  function draw(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,pxW,pxH);

    ctx.setTransform(scale,0,0,scale, offX, offY);

    // background wash
    const bg = ctx.createLinearGradient(0,0,0,CFG.tableH);
    bg.addColorStop(0, "rgba(74,124,145,0.10)");
    bg.addColorStop(1, "rgba(74,124,145,0.00)");
    ctx.fillStyle = bg;
    ctx.fillRect(0,0,CFG.tableW,CFG.tableH);

    // soft dots
    ctx.save();
    ctx.globalAlpha = 0.06;
    ctx.fillStyle = "rgba(45,42,38,1)";
    for(let y=24;y<CFG.tableH;y+=36){
      for(let x=18;x<CFG.tableW;x+=36){
        ctx.beginPath();
        ctx.arc(x + (y%72?8:0), y, 1.2, 0, Math.PI*2);
        ctx.fill();
      }
    }
    ctx.restore();

    // rail (visual)
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.strokeStyle = "rgba(45,42,38,1)";
    ctx.lineWidth = 18;
    ctx.lineCap="round";
    ctx.beginPath();
    ctx.moveTo(14, 18);
    ctx.lineTo(CFG.tableW-14, 18);
    ctx.lineTo(CFG.tableW-14, CFG.tableH-210);
    ctx.lineTo(CFG.tableW*0.62, CFG.tableH-26);
    ctx.moveTo(CFG.tableW*0.38, CFG.tableH-26);
    ctx.lineTo(14, CFG.tableH-210);
    ctx.lineTo(14, 18);
    ctx.stroke();
    ctx.restore();

    // physics walls
    ctx.strokeStyle="rgba(45,42,38,0.22)";
    ctx.lineWidth=6;
    ctx.lineCap="round";
    for(const w of walls){
      ctx.beginPath(); ctx.moveTo(w.x1,w.y1); ctx.lineTo(w.x2,w.y2); ctx.stroke();
    }

    // slings
    ctx.strokeStyle="rgba(123,160,138,0.40)";
    ctx.lineWidth=6;
    for(const s of slings){
      ctx.beginPath(); ctx.moveTo(s.x1,s.y1); ctx.lineTo(s.x2,s.y2); ctx.stroke();
    }

    // rollovers (visual)
    for(const r of rollovers){
      r.glow = r.data.hit ? 1 : 0;
      ctx.save();
      ctx.globalAlpha = 0.15 + (r.data.hit ? 0.20 : 0);
      ctx.fillStyle = r.data.color;
      ctx.beginPath(); ctx.arc(r.x,r.y,r.r+7,0,Math.PI*2); ctx.fill();
      ctx.restore();

      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.beginPath(); ctx.arc(r.x,r.y,r.r,0,Math.PI*2); ctx.fill();
      ctx.lineWidth=2;
      ctx.strokeStyle="rgba(45,42,38,0.16)";
      ctx.stroke();
    }

    // gate/targets/bumpers
    gate.forEach(g => drawStickerCircle(g, true));
    targets.forEach(t => drawStickerCircle(t, false));
    bumpers.forEach(b => drawStickerCircle(b, true));

    // flippers
    drawFlipper(flL);
    drawFlipper(flR);

    // plunger lane hint + meter
    ctx.save();
    ctx.globalAlpha=0.10;
    ctx.fillStyle="rgba(74,124,145,1)";
    ctx.fillRect(CFG.tableW*0.80, CFG.tableH*0.52, (CFG.tableW*0.92-CFG.tableW*0.80), CFG.tableH*0.38);
    ctx.restore();

    if(ball.inPlunger && plPower>0){
      const frac = clamp(plPower/CFG.plungerMax,0,1);
      ctx.save();
      ctx.globalAlpha=0.70;
      ctx.fillStyle="rgba(74,124,145,1)";
      const h = frac*210;
      ctx.fillRect(CFG.tableW-10, CFG.tableH-55-h, 6, h);
      ctx.restore();

      ctx.save();
      ctx.globalAlpha=0.85;
      ctx.font="900 12px Nunito";
      ctx.fillStyle="rgba(45,42,38,0.60)";
      ctx.fillText("HALTEN ‚Üí LOS", CFG.tableW-118, CFG.tableH-86-h*0.25);
      ctx.restore();
    }

    // kickback hint (visual)
    if(kickbackReady){
      ctx.save();
      ctx.globalAlpha=0.18;
      ctx.fillStyle="rgba(232,197,71,1)";
      ctx.beginPath();
      ctx.roundRect(12, CFG.tableH-160, 74, 42, 12);
      ctx.fill();
      ctx.globalAlpha=0.82;
      ctx.font="900 14px Nunito";
      ctx.fillStyle="rgba(45,42,38,0.78)";
      ctx.fillText("üõü", 32, CFG.tableH-134);
      ctx.font="900 10px Nunito";
      ctx.fillText("KICKBACK", 18, CFG.tableH-120);
      ctx.restore();
    }

    // ball
    ctx.fillStyle="rgba(255,255,255,0.97)";
    ctx.beginPath(); ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2); ctx.fill();
    ctx.lineWidth=2;
    ctx.strokeStyle="rgba(45,42,38,0.20)";
    ctx.stroke();

    // ball save halo
    if(!ball.inPlunger && ball.saveT>0){
      ctx.save();
      ctx.globalAlpha=0.12;
      ctx.strokeStyle="rgba(74,124,145,1)";
      ctx.lineWidth=6;
      ctx.beginPath(); ctx.arc(ball.x,ball.y,ball.r+9,0,Math.PI*2); ctx.stroke();
      ctx.restore();
    }

    // confetti
    if(confetti.length){
      for(const p of confetti){
        ctx.save();
        ctx.globalAlpha = 0.9;
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        ctx.fillStyle = p.c;
        ctx.fillRect(-p.r, -p.r, p.r*2, p.r*2);
        ctx.restore();
      }
    }
  }

  // ===== Main loop =====
  function loop(now){
    const dt = Math.min(CFG.maxFrameDt, (now-last)/1000);
    last = now;

    acc += dt;
    while(acc >= STEP){
      physicsStep(STEP);
      acc -= STEP;
    }
    draw();
    requestAnimationFrame(loop);
  }

  // ===== Start =====
  buildTable();
  resetGame();
  updateOverlayButtons();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
