<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Logic Pinball Pro - Fixed</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --neon-blue: #00f2ff;
            --neon-pink: #ff007f;
            --neon-green: #39ff14;
            --neon-yellow: #fff200;
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020205;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            color: white;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100dvh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            background: radial-gradient(circle at 50% 20%, #0a0a1a 0%, #020205 100%);
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.5);
            max-width: 100%;
            max-height: 100%;
            display: block;
            border: 2px solid #111;
        }
        .hud {
            position: absolute;
            top: env(safe-area-inset-top);
            width: 100%;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 50;
        }
        .stats-box {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--neon-blue);
            padding: 10px 15px;
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(0, 242, 255, 0.3);
            min-width: 120px;
        }
        .multiplier {
            color: var(--neon-green);
            font-weight: bold;
        }
        #message-box {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid var(--neon-blue);
            padding: 30px;
            text-align: center;
            display: none;
            z-index: 100;
            border-radius: 8px;
            box-shadow: 0 0 50px var(--neon-blue);
        }
        .btn {
            background: var(--neon-blue);
            color: black;
            font-weight: bold;
            padding: 10px 25px;
            border: none;
            cursor: pointer;
            margin-top: 20px;
            text-transform: uppercase;
            border-radius: 4px;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div class="hud">
        <div class="stats-box">
            <div>SCORE: <span id="score">0</span></div>
            <div class="multiplier">MULTI: X<span id="mult">1</span></div>
        </div>
        <div class="stats-box text-right">
            <div>BÄLLE: <span id="lives">3</span></div>
            <div id="status-msg" style="font-size: 0.7rem; color: var(--neon-pink)">DRÜCKE LEERTASTE</div>
        </div>
    </div>

    <div id="message-box">
        <h2 id="msg-title" class="text-3xl font-bold mb-2">SPIEL VORBEI</h2>
        <p id="msg-text" class="mb-4">Keine Bälle mehr übrig.</p>
        <button class="btn" onclick="game.reset()">NEUSTART</button>
    </div>

    <canvas id="pinballCanvas"></canvas>
</div>

<script>
/**
 * PINBALL ENGINE v2.1 - PHYSICS STABILITY UPDATE
 */

const canvas = document.getElementById('pinballCanvas');
const ctx = canvas.getContext('2d');

const WIDTH = 400;
const HEIGHT = 700;
const BALL_RADIUS = 9;
const P_STEP = 8; // Physics steps for ultra-stability

class PinballGame {
    constructor() {
        this.setupCanvas();
        this.resetVariables();
        this.initInput();
        this.createTable();
        this.loop();
    }

    setupCanvas() {
        this.scale = window.devicePixelRatio || 1;
        canvas.width = WIDTH * this.scale;
        canvas.height = HEIGHT * this.scale;
        canvas.style.width = WIDTH + 'px';
        canvas.style.height = HEIGHT + 'px';
        ctx.scale(this.scale, this.scale);
    }

    resetVariables() {
        this.score = 0;
        this.lives = 3;
        this.multiplier = 1;
        this.gameOver = false;
        this.ball = {
            x: WIDTH - 25,
            y: HEIGHT - 50,
            vx: 0,
            vy: 0,
            active: true
        };
        this.keys = { left: false, right: false };
        this.updateHUD();
    }

    initInput() {
        window.onkeydown = (e) => {
            if(e.key === 'ArrowLeft') this.keys.left = true;
            if(e.key === 'ArrowRight') this.keys.right = true;
            if(e.key === ' ') this.launch();
        };
        window.onkeyup = (e) => {
            if(e.key === 'ArrowLeft') this.keys.left = false;
            if(e.key === 'ArrowRight') this.keys.right = false;
        };
        canvas.ontouchstart = (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            for(let t of e.changedTouches) {
                const x = (t.clientX - rect.left) / rect.width;
                if(x < 0.5) this.keys.left = true;
                else this.keys.right = true;
                this.launch();
            }
        };
        canvas.ontouchend = (e) => {
            e.preventDefault();
            this.keys.left = false;
            this.keys.right = false;
        };
    }

    createTable() {
        this.walls = [
            { x1: 0, y1: 80, x2: 80, y2: 0 }, // Top left
            { x1: WIDTH-120, y1: 0, x2: WIDTH-50, y2: 70 }, // Top right
            { x1: 0, y1: 0, x2: WIDTH-50, y2: 0 }, // Ceiling
            { x1: 0, y1: 0, x2: 0, y2: HEIGHT }, // Left
            { x1: WIDTH, y1: 0, x2: WIDTH, y2: HEIGHT }, // Right
            { x1: WIDTH-50, y1: 100, x2: WIDTH-50, y2: HEIGHT }, // Plunger wall
            // Drain
            { x1: 0, y1: HEIGHT-150, x2: 120, y2: HEIGHT-60 },
            { x1: WIDTH-50, y1: HEIGHT-150, x2: WIDTH-170, y2: HEIGHT-60 },
            // Floor for Plunger
            { x1: WIDTH-50, y1: HEIGHT-5, x2: WIDTH, y2: HEIGHT-5 }
        ];

        this.bumpers = [
            { x: 130, y: 150, r: 25, color: '#ff007f', pts: 100, pulse: 0 },
            { x: 270, y: 150, r: 25, color: '#ff007f', pts: 100, pulse: 0 },
            { x: 200, y: 240, r: 35, color: '#00f2ff', pts: 250, pulse: 0 }
        ];

        this.flippers = [
            { side: 'left', x: 120, y: HEIGHT-60, length: 70, angle: 0.5, baseAngle: 0.5, targetAngle: -0.6, width: 14 },
            { side: 'right', x: WIDTH-170, y: HEIGHT-60, length: 70, angle: Math.PI-0.5, baseAngle: Math.PI-0.5, targetAngle: Math.PI+0.6, width: 14 }
        ];

        this.targets = [
            { x: 30, y: 250, w: 12, h: 45, active: true },
            { x: 30, y: 310, w: 12, h: 45, active: true },
            { x: 30, y: 370, w: 12, h: 45, active: true }
        ];

        this.lanes = [
            { x: 100, y: 20, w: 35, h: 10, hit: false, color: '#fff200' },
            { x: 150, y: 20, w: 35, h: 10, hit: false, color: '#fff200' },
            { x: 200, y: 20, w: 35, h: 10, hit: false, color: '#fff200' }
        ];
        
        this.slingshots = [
            { x1: 85, y1: HEIGHT-210, x2: 120, y2: HEIGHT-110, active: 0 },
            { x1: WIDTH-135, y1: HEIGHT-210, x2: WIDTH-170, y2: HEIGHT-110, active: 0 }
        ];
    }

    launch() {
        if (this.ball.y > HEIGHT - 100 && this.ball.x > WIDTH - 55) {
            this.ball.vy = -26;
            this.ball.vx = (Math.random() - 0.5) * 2;
            this.updateStatus("ABSCHUSS!");
        }
    }

    update() {
        if (this.gameOver) return;

        // Flipper Logic
        this.flippers.forEach(f => {
            const speed = 0.55;
            const isPressed = (f.side === 'left' ? this.keys.left : this.keys.right);
            if(isPressed) {
                f.angle = (f.side === 'left') ? Math.max(f.targetAngle, f.angle - speed) : Math.min(f.targetAngle, f.angle + speed);
            } else {
                f.angle = (f.side === 'left') ? Math.min(f.baseAngle, f.angle + speed * 0.4) : Math.max(f.baseAngle, f.angle - speed * 0.4);
            }
        });

        // Ball Physics Sub-stepping
        for(let i=0; i < P_STEP; i++) {
            this.ball.vy += 0.38 / P_STEP;
            this.ball.vx *= Math.pow(0.998, 1/P_STEP);
            this.ball.vy *= Math.pow(0.998, 1/P_STEP);
            this.ball.x += this.ball.vx / P_STEP;
            this.ball.y += this.ball.vy / P_STEP;

            this.checkCollisions();
        }

        // Out of bounds
        if(this.ball.y > HEIGHT + 50) this.ballLost();

        // Game Logic updates
        if(this.lanes.every(l => l.hit)) {
            this.multiplier++;
            this.lanes.forEach(l => l.hit = false);
            this.updateStatus("MULTI-BONUS! X" + this.multiplier);
            this.updateHUD();
        }

        if(this.targets.every(t => !t.active)) {
            this.score += 5000 * this.multiplier;
            this.targets.forEach(t => t.active = true);
            this.updateStatus("TARGETS RESET!");
            this.updateHUD();
        }
    }

    checkCollisions() {
        // Walls
        this.walls.forEach(w => this.resolveLineCollision(this.ball, w.x1, w.y1, w.x2, w.y2, 0.7));

        // Bumpers
        this.bumpers.forEach(b => {
            const d = Math.hypot(this.ball.x - b.x, this.ball.y - b.y);
            if(d < BALL_RADIUS + b.r) {
                const nx = (this.ball.x - b.x) / d;
                const ny = (this.ball.y - b.y) / d;
                this.reflect(this.ball, nx, ny, 1.6);
                this.score += b.pts * this.multiplier;
                b.pulse = 15;
                this.updateHUD();
            }
            if(b.pulse > 0) b.pulse--;
        });

        // Flippers
        this.flippers.forEach(f => {
            const x2 = f.x + Math.cos(f.angle) * f.length;
            const y2 = f.y + Math.sin(f.angle) * f.length;
            const hit = this.resolveLineCollision(this.ball, f.x, f.y, x2, y2, 0.8, true);
            if(hit) {
                const isMovingUp = (f.side === 'left' && this.keys.left) || (f.side === 'right' && this.keys.right);
                if(isMovingUp) {
                    this.ball.vy -= 6; // Extra punch
                    this.ball.vx += (f.side === 'left' ? 2 : -2);
                }
            }
        });

        // Targets
        this.targets.forEach(t => {
            if(!t.active) return;
            if(this.ball.x + BALL_RADIUS > t.x && this.ball.x - BALL_RADIUS < t.x + t.w &&
               this.ball.y + BALL_RADIUS > t.y && this.ball.y - BALL_RADIUS < t.y + t.h) {
                t.active = false;
                this.ball.vx *= -1.1; // Bounce back
                this.score += 1000 * this.multiplier;
                this.updateHUD();
            }
        });

        // Lanes
        this.lanes.forEach(l => {
            if(!l.hit && this.ball.x > l.x && this.ball.x < l.x + l.w && this.ball.y > l.y && this.ball.y < l.y + l.h) {
                l.hit = true;
                this.score += 500;
                this.updateHUD();
            }
        });

        // Slingshots
        this.slingshots.forEach(s => {
            const hit = this.resolveLineCollision(this.ball, s.x1, s.y1, s.x2, s.y2, 1.4);
            if(hit) {
                s.active = 10;
                this.score += 50;
                this.updateHUD();
            }
            if(s.active > 0) s.active--;
        });
    }

    resolveLineCollision(ball, x1, y1, x2, y2, bounce, isFlipper=false) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const l2 = dx*dx + dy*dy;
        if(l2 === 0) return false;
        let t = ((ball.x - x1) * dx + (ball.y - y1) * dy) / l2;
        t = Math.max(0, Math.min(1, t));
        const nx_pt = x1 + t * dx;
        const ny_pt = y1 + t * dy;
        const dist = Math.hypot(ball.x - nx_pt, ball.y - ny_pt);

        const threshold = isFlipper ? BALL_RADIUS + 4 : BALL_RADIUS;
        if(dist < threshold) {
            // Calculate normal with safety for dist=0
            const nx = dist > 0 ? (ball.x - nx_pt) / dist : 0;
            const ny = dist > 0 ? (ball.y - ny_pt) / dist : -1;
            
            this.reflect(ball, nx, ny, bounce);
            // Push ball out of geometry to prevent sticking
            ball.x = nx_pt + nx * (threshold + 1);
            ball.y = ny_pt + ny * (threshold + 1);
            return true;
        }
        return false;
    }

    reflect(ball, nx, ny, bounce) {
        const dot = ball.vx * nx + ball.vy * ny;
        if(dot < 0) { // Only reflect if moving towards the surface
            ball.vx = (ball.vx - 2 * dot * nx) * bounce;
            ball.vy = (ball.vy - 2 * dot * ny) * bounce;
        }
    }

    ballLost() {
        this.lives--;
        this.updateHUD();
        if(this.lives <= 0) {
            this.gameOver = true;
            document.getElementById('message-box').style.display = 'block';
            document.getElementById('status-msg').innerText = "GAME OVER";
        } else {
            this.ball.x = WIDTH - 25;
            this.ball.y = HEIGHT - 50;
            this.ball.vx = 0;
            this.ball.vy = 0;
            this.updateStatus("BALL VERLOREN!");
        }
    }

    updateHUD() {
        document.getElementById('score').innerText = this.score.toLocaleString();
        document.getElementById('lives').innerText = this.lives;
        document.getElementById('mult').innerText = this.multiplier;
    }

    updateStatus(msg) {
        const el = document.getElementById('status-msg');
        el.innerText = msg;
        setTimeout(() => { if(!this.gameOver) el.innerText = "BEREIT"; }, 1500);
    }

    reset() {
        document.getElementById('message-box').style.display = 'none';
        this.resetVariables();
        this.createTable();
    }

    draw() {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);

        // Decor Grid
        ctx.strokeStyle = '#0a0a1a';
        ctx.lineWidth = 1;
        for(let i=0; i<WIDTH; i+=40) {
            ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, HEIGHT); ctx.stroke();
        }

        // Walls
        ctx.strokeStyle = '#222233';
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';
        this.walls.forEach(w => {
            ctx.beginPath(); ctx.moveTo(w.x1, w.y1); ctx.lineTo(w.x2, w.y2); ctx.stroke();
        });

        // Slingshots
        this.slingshots.forEach(s => {
            ctx.strokeStyle = s.active > 0 ? 'white' : '#00f2ff';
            ctx.shadowBlur = s.active > 0 ? 15 : 0;
            ctx.shadowColor = '#00f2ff';
            ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(s.x1, s.y1); ctx.lineTo(s.x2, s.y2); ctx.stroke();
            ctx.shadowBlur = 0;
        });

        // Lanes
        this.lanes.forEach(l => {
            ctx.fillStyle = l.hit ? l.color : '#111';
            ctx.shadowBlur = l.hit ? 15 : 0;
            ctx.shadowColor = l.color;
            ctx.fillRect(l.x, l.y, l.w, l.h);
            ctx.shadowBlur = 0;
        });

        // Bumpers
        this.bumpers.forEach(b => {
            const pulseSize = b.pulse ? b.pulse/1.5 : 0;
            ctx.fillStyle = b.color;
            ctx.shadowBlur = 20 + pulseSize;
            ctx.shadowColor = b.color;
            ctx.beginPath(); ctx.arc(b.x, b.y, b.r + pulseSize, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath(); ctx.arc(b.x, b.y, (b.r + pulseSize)*0.7, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;
        });

        // Targets
        this.targets.forEach(t => {
            if(!t.active) return;
            ctx.fillStyle = '#39ff14';
            ctx.shadowBlur = 10; ctx.shadowColor = '#39ff14';
            ctx.fillRect(t.x, t.y, t.w, t.h);
            ctx.shadowBlur = 0;
        });

        // Flipper
        ctx.lineCap = 'round';
        this.flippers.forEach(f => {
            ctx.strokeStyle = '#00f2ff';
            ctx.lineWidth = f.width;
            ctx.shadowBlur = 12; ctx.shadowColor = '#00f2ff';
            ctx.beginPath();
            ctx.moveTo(f.x, f.y);
            ctx.lineTo(f.x + Math.cos(f.angle)*f.length, f.y + Math.sin(f.angle)*f.length);
            ctx.stroke();
            ctx.shadowBlur = 0;
        });

        // Ball
        if(this.ball.active) {
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 15; ctx.shadowColor = '#fff';
            ctx.beginPath(); ctx.arc(this.ball.x, this.ball.y, BALL_RADIUS, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;
        }
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
}

const game = new PinballGame();
</script>
</body>
</html>
