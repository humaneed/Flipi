<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Neon Pinball Mobile</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --neon-cyan: #0ff;
            --neon-magenta: #f0f;
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050508;
            font-family: system-ui, -apple-system, sans-serif;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100dvh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        canvas {
            background: radial-gradient(circle at center, #1a1a2e 0%, #050508 100%);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.15);
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            display: block;
        }
        .ui-overlay {
            position: absolute;
            top: calc(10px + env(safe-area-inset-top));
            left: 50%;
            transform: translateX(-50%);
            color: var(--neon-cyan);
            text-shadow: 0 0 8px var(--neon-cyan);
            font-weight: 800;
            pointer-events: none;
            display: flex;
            gap: 30px;
            z-index: 10;
            font-size: 1.2rem;
            width: 100%;
            justify-content: center;
        }
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--neon-cyan);
            color: #fff;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 100;
            width: 80%;
            max-width: 320px;
            backdrop-filter: blur(5px);
        }
        button {
            background: var(--neon-cyan);
            color: #000;
            border: none;
            padding: 15px 30px;
            margin-top: 20px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1rem;
            text-transform: uppercase;
            box-shadow: 0 0 15px var(--neon-cyan);
        }
        .touch-hint {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            opacity: 0.3;
            pointer-events: none;
            color: white;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div class="ui-overlay">
        <div>SCORE: <span id="score">0</span></div>
        <div>LIVES: <span id="lives">3</span></div>
    </div>

    <div id="message-box" class="message-box">
        <h2 id="msg-title" class="text-3xl mb-2 font-black">GAME OVER</h2>
        <p id="msg-text" class="text-lg opacity-80">Dein Score: 0</p>
        <button onclick="resetGame()">NEUSTART</button>
    </div>

    <canvas id="pinballCanvas"></canvas>
    
    <div class="touch-hint">
        <span>⬅ FLIPPER</span>
        <span>FLIPPER ➡</span>
    </div>
</div>

<script>
/**
 * MOBILE OPTIMIZED PINBALL - FIXED PHYSICS NORMALS
 */

const canvas = document.getElementById('pinballCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const messageBox = document.getElementById('message-box');
const msgTitle = document.getElementById('msg-title');
const msgText = document.getElementById('msg-text');

const WIDTH = 400;
const HEIGHT = 600;

function setupCanvas() {
    const scale = window.devicePixelRatio || 1;
    canvas.style.width = '400px';
    canvas.style.height = '600px';
    canvas.width = WIDTH * scale;
    canvas.height = HEIGHT * scale;
    ctx.scale(scale, scale);
}

setupCanvas();

const GRAVITY = 0.35;
const FRICTION = 0.99;
const MAX_SPEED = 18;

let score = 0;
let lives = 3;
let gameOver = false;

const keys = { left: false, right: false };

let ball = {
    x: WIDTH - 25,
    y: HEIGHT - 50,
    vx: 0,
    vy: 0,
    radius: 9,
    color: '#fff'
};

const flippers = [
    { side: 'left', x: WIDTH / 2 - 85, y: HEIGHT - 100, length: 75, angle: 0.5, baseAngle: 0.5, targetAngle: -0.6, isUp: false, width: 12 },
    { side: 'right', x: WIDTH / 2 + 85, y: HEIGHT - 100, length: 75, angle: Math.PI - 0.5, baseAngle: Math.PI - 0.5, targetAngle: Math.PI + 0.6, isUp: false, width: 12 }
];

const bumpers = [
    { x: 100, y: 160, radius: 25, color: '#f0f', points: 100, pulse: 0 },
    { x: 300, y: 160, radius: 25, color: '#f0f', points: 100, pulse: 0 },
    { x: 200, y: 260, radius: 32, color: '#0ff', points: 250, pulse: 0 },
    { x: 60, y: 360, radius: 22, color: '#ff0', points: 50, pulse: 0 },
    { x: 340, y: 360, radius: 22, color: '#ff0', points: 50, pulse: 0 }
];

const walls = [
    { x1: 0, y1: 0, x2: WIDTH, y2: 0 }, // Decke
    { x1: 0, y1: 0, x2: 0, y2: HEIGHT }, // Links
    { x1: WIDTH, y1: 0, x2: WIDTH, y2: HEIGHT }, // Rechts
    { x1: 0, y1: HEIGHT - 180, x2: WIDTH/2 - 85, y2: HEIGHT - 100 }, // Schräge Links
    { x1: WIDTH, y1: HEIGHT - 180, x2: WIDTH/2 + 85, y2: HEIGHT - 100 }, // Schräge Rechts
    { x1: WIDTH - 50, y1: HEIGHT, x2: WIDTH - 50, y2: 120 }, // Plunger Wand
    { x1: WIDTH - 50, y1: HEIGHT - 5, x2: WIDTH, y2: HEIGHT - 5 } // Plunger Boden
];

// Input Handling
window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft') keys.left = true;
    if (e.key === 'ArrowRight') keys.right = true;
    if (e.key === ' ' && !gameOver) launchBall();
});
window.addEventListener('keyup', (e) => {
    if (e.key === 'ArrowLeft') keys.left = false;
    if (e.key === 'ArrowRight') keys.right = false;
});

canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        const x = (t.clientX - rect.left) / rect.width;
        if (x < 0.5) keys.left = true;
        else keys.right = true;
        if (ball.y > HEIGHT - 120) launchBall();
    }
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    let stillLeft = false; let stillRight = false;
    for (let i = 0; i < e.touches.length; i++) {
        const t = e.touches[i];
        const x = (t.clientX - rect.left) / rect.width;
        if (x < 0.5) stillLeft = true;
        else stillRight = true;
    }
    keys.left = stillLeft;
    keys.right = stillRight;
}, { passive: false });

function launchBall() {
    // Nur abschießen, wenn der Ball im Plunger-Kanal ist
    if (ball.y > HEIGHT - 120 && ball.x > WIDTH - 55) {
        ball.vy = -24;
        ball.vx = (Math.random() - 0.5) * 2;
    }
}

function resetBall() {
    lives--;
    livesEl.innerText = lives;
    if (lives <= 0) endGame();
    else {
        ball.x = WIDTH - 25;
        ball.y = HEIGHT - 60;
        ball.vx = 0;
        ball.vy = 0;
    }
}

function endGame() {
    gameOver = true;
    msgTitle.innerText = "SPIEL VORBEI";
    msgText.innerText = "Dein Score: " + score;
    messageBox.style.display = 'block';
}

function resetGame() {
    score = 0; scoreEl.innerText = score;
    lives = 3; livesEl.innerText = lives;
    gameOver = false;
    messageBox.style.display = 'none';
    ball.x = WIDTH - 25; ball.y = HEIGHT - 60;
    ball.vx = 0; ball.vy = 0;
}

function distance(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
}

function update() {
    if (gameOver) return;

    // Flipper Rotation
    flippers.forEach(f => {
        const step = 0.5;
        if (f.side === 'left') {
            f.isUp = keys.left;
            if (f.isUp) f.angle = Math.max(f.targetAngle, f.angle - step);
            else f.angle = Math.min(f.baseAngle, f.angle + step * 0.4);
        } else {
            f.isUp = keys.right;
            if (f.isUp) f.angle = Math.min(f.targetAngle, f.angle + step);
            else f.angle = Math.max(f.baseAngle, f.angle - step * 0.4);
        }
    });

    // Ball Bewegung
    ball.vy += GRAVITY;
    ball.vx *= FRICTION;
    ball.vy *= FRICTION;
    ball.x += ball.vx;
    ball.y += ball.vy;

    // Speed Limit
    const currentSpeed = Math.sqrt(ball.vx**2 + ball.vy**2);
    if (currentSpeed > MAX_SPEED) {
        ball.vx = (ball.vx / currentSpeed) * MAX_SPEED;
        ball.vy = (ball.vy / currentSpeed) * MAX_SPEED;
    }

    // Wand Kollisionen
    walls.forEach(w => {
        const dx = w.x2 - w.x1;
        const dy = w.y2 - w.y1;
        const l2 = dx*dx + dy*dy;
        if (l2 === 0) return;
        let t = Math.max(0, Math.min(1, ((ball.x - w.x1) * dx + (ball.y - w.y1) * dy) / l2));
        const nearestX = w.x1 + t * dx;
        const nearestY = w.y1 + t * dy;
        const dist = distance(ball.x, ball.y, nearestX, nearestY);
        
        if (dist < ball.radius) {
            // Berechnung der Normalen vom nächsten Punkt zum Ball (Fixes the tunneling/push-out issue)
            const nx = (ball.x - nearestX) / dist;
            const ny = (ball.y - nearestY) / dist;
            
            // Reflektion basierend auf der Normalen
            const dot = ball.vx * nx + ball.vy * ny;
            ball.vx = (ball.vx - 2 * dot * nx) * 0.7;
            ball.vy = (ball.vy - 2 * dot * ny) * 0.7;
            
            // Ball aus der Wand schieben
            ball.x = nearestX + nx * ball.radius;
            ball.y = nearestY + ny * ball.radius;
        }
    });

    // Bumper Kollisionen
    bumpers.forEach(b => {
        const dist = distance(ball.x, ball.y, b.x, b.y);
        if (dist < ball.radius + b.radius) {
            const angle = Math.atan2(ball.y - b.y, ball.x - b.x);
            const force = 12;
            ball.vx = Math.cos(angle) * force;
            ball.vy = Math.sin(angle) * force;
            score += b.points;
            scoreEl.innerText = score;
            b.pulse = 15;
        }
        if (b.pulse > 0) b.pulse -= 1;
    });

    // Flipper Kollisionen
    flippers.forEach(f => {
        const endX = f.x + Math.cos(f.angle) * f.length;
        const endY = f.y + Math.sin(f.angle) * f.length;
        const dx = endX - f.x;
        const dy = endY - f.y;
        const l2 = dx*dx + dy*dy;
        let t = Math.max(0, Math.min(1, ((ball.x - f.x) * dx + (ball.y - f.y) * dy) / l2));
        const nearestX = f.x + t * dx;
        const nearestY = f.y + t * dy;
        const dist = distance(ball.x, ball.y, nearestX, nearestY);

        if (dist < ball.radius + f.width/2) {
            const nx = (ball.x - nearestX) / dist;
            const ny = (ball.y - nearestY) / dist;
            const strength = f.isUp ? 16 : 4;
            
            ball.vx = nx * strength + (Math.random()-0.5)*2;
            ball.vy = ny * strength;
            ball.x = nearestX + nx * (ball.radius + f.width/2);
            ball.y = nearestY + ny * (ball.radius + f.width/2);
        }
    });

    // Ball im Aus
    if (ball.y > HEIGHT + 50) resetBall();
}

function draw() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    ctx.strokeStyle = '#1e1e2e';
    ctx.lineWidth = 4;
    walls.forEach(w => {
        ctx.beginPath(); ctx.moveTo(w.x1, w.y1); ctx.lineTo(w.x2, w.y2); ctx.stroke();
    });

    bumpers.forEach(b => {
        const r = b.radius + b.pulse;
        ctx.shadowBlur = 15; ctx.shadowColor = b.color;
        ctx.fillStyle = b.color;
        ctx.beginPath(); ctx.arc(b.x, b.y, r, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;
    });

    ctx.lineCap = 'round';
    flippers.forEach(f => {
        ctx.shadowBlur = 12; ctx.shadowColor = '#0ff';
        ctx.strokeStyle = '#0ff'; ctx.lineWidth = f.width;
        ctx.beginPath(); ctx.moveTo(f.x, f.y);
        ctx.lineTo(f.x + Math.cos(f.angle) * f.length, f.y + Math.sin(f.angle) * f.length);
        ctx.stroke();
        ctx.shadowBlur = 0;
    });

    ctx.shadowBlur = 10; ctx.shadowColor = '#0ff';
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2); ctx.fill();
    ctx.shadowBlur = 0;

    requestAnimationFrame(() => {
        update();
        draw();
    });
}

window.addEventListener('resize', setupCanvas);
window.onload = draw;
</script>
</body>
</html>
