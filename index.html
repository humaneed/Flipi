<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="theme-color" content="#4A7C91" />
  <title>Kidsneed – Premium Pinball (stable)</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@600;800;900&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#F5F0E8;
      --card:#FFFFFF;
      --muted:#EDE8DC;
      --ink:#2D2A26;
      --ink2:#6B665C;
      --accent:#4A7C91;

      --r-md:16px;
      --r-lg:24px;
      --shadow:0 8px 24px rgba(45,42,38,.12);
      --shadow2:0 2px 10px rgba(45,42,38,.10);

      --s1:8px; --s2:12px; --s3:16px; --s4:24px;
      --maxw:560px;
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color:transparent;}
    html,body{height:100%;}
    body{
      margin:0;
      background:var(--bg);
      font-family:Nunito, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:var(--ink);
      overscroll-behavior:none;
      touch-action:none;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:calc(env(safe-area-inset-top) + var(--s3)) var(--s3) calc(env(safe-area-inset-bottom) + var(--s3));
    }

    .frame{
      width:100%;
      max-width:var(--maxw);
      height: min(92dvh, 920px);
      background:var(--card);
      border:3px solid var(--ink);
      border-radius:var(--r-lg);
      box-shadow:var(--shadow2);
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }

    .topbar{
      height:72px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:var(--s2);
      padding:0 var(--s3);
      border-bottom:3px solid var(--ink);
      background:var(--card);
    }
    .title{
      display:flex; flex-direction:column; gap:2px; min-width:0;
    }
    .title b{
      font-size:18px; font-weight:900; letter-spacing:-.02em;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .title small{
      font-weight:900; font-size:12px; letter-spacing:.10em;
      color:var(--ink2); text-transform:uppercase;
    }
    .chips{display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;}
    .chip{
      display:inline-flex; align-items:center; gap:8px;
      padding:10px 12px;
      border-radius:999px;
      border:2px solid var(--ink);
      background:var(--muted);
      font-weight:900;
      user-select:none;
      white-space:nowrap;
    }
    .chip span{color:var(--ink2); font-weight:900; font-size:12px; letter-spacing:.10em; text-transform:uppercase;}
    .chip b{font-size:14px;}
    .btn{
      border:2px solid var(--ink);
      background:var(--muted);
      border-radius:12px;
      padding:10px 12px;
      font-weight:900;
      cursor:pointer;
    }
    .btn:active{transform:translateY(1px);}

    .stage{
      position:relative;
      flex:1;
      padding:var(--s3);
      background:
        radial-gradient(900px 320px at 50% 0%, rgba(74,124,145,.12), transparent 60%),
        var(--card);
    }
    .board{
      position:absolute;
      inset:var(--s3);
      border-radius:var(--r-lg);
      border:3px solid var(--ink);
      box-shadow:var(--shadow);
      overflow:hidden;
      background: linear-gradient(180deg, rgba(237,232,220,.55), rgba(255,255,255,1));
    }
    canvas{width:100%; height:100%; display:block;}
    .zones{position:absolute; inset:0; display:flex;}
    .zone{flex:1; background:transparent; touch-action:none;}

    .toast{
      position:absolute;
      left:50%; top:16px;
      transform:translateX(-50%) translateY(-6px);
      padding:10px 14px;
      border-radius:999px;
      background:rgba(45,42,38,.92);
      color:#fff;
      font-weight:900;
      opacity:0;
      transition:opacity .16s ease, transform .16s ease;
      pointer-events:none;
      box-shadow:0 10px 30px rgba(0,0,0,.18);
    }
    .toast.show{opacity:1; transform:translateX(-50%) translateY(0);}

    .overlay{
      position:absolute; inset:0;
      display:none; align-items:center; justify-content:center;
      background:rgba(245,240,232,.72);
      backdrop-filter:blur(6px);
      padding:var(--s3);
    }
    .panel{
      width:min(420px, 100%);
      background:var(--card);
      border:3px solid var(--ink);
      border-radius:var(--r-lg);
      box-shadow:var(--shadow);
      padding:var(--s4);
    }
    .panel h2{margin:0 0 var(--s2); font-size:20px; font-weight:900;}
    .panel p{margin:0 0 var(--s3); color:var(--ink2); font-weight:800;}
    .panel .row{display:flex; gap:var(--s2); justify-content:space-between;}
  </style>
</head>
<body>
  <div class="frame">
    <div class="topbar">
      <div class="title">
        <b>Premium Pinball</b>
        <small>Kidsneed Arcade</small>
      </div>

      <div class="chips">
        <div class="chip"><span>Ziel</span><b id="target">10</b></div>
        <div class="chip"><span>Summe</span><b id="sum">0</b></div>
        <div class="chip"><span>x</span><b id="mult">1</b></div>
        <div class="chip"><span>⭐</span><b id="score">0</b></div>
        <button class="btn" id="resetBtn" title="Neu">↻</button>
      </div>
    </div>

    <div class="stage">
      <div class="board" id="board">
        <canvas id="cv"></canvas>
        <div class="toast" id="toast">JACKPOT!</div>
        <div class="zones" aria-hidden="true">
          <div class="zone" id="zl"></div>
          <div class="zone" id="zr"></div>
        </div>

        <div class="overlay" id="over">
          <div class="panel">
            <h2 id="overTitle">Game Over</h2>
            <p id="overText">Keine Bälle mehr übrig.</p>
            <div class="row">
              <button class="btn" id="overRestart">Neu starten</button>
              <button class="btn" id="overClose">Schließen</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  // ---- Tunables (einfach diversifizieren später) ----
  const CFG = {
    tableW: 400,
    tableH: 700,

    ballR: 9,
    gravity: 1200,         // px/s^2
    damping: 0.995,        // air friction
    maxSpeed: 1700,

    wallRest: 0.92,
    bumperRest: 1.08,
    slingRest: 1.10,
    flipperRest: 0.90,

    // Smart layer
    targetCycle: [10, 12, 15],
    bumperChips: [1, 2, 3],
    jackpotBase: 650,
    softBust: true,
    multMax: 5,

    // Flippers
    flLen: 72,
    flWidth: 14,
    flRestAngle: 0.50,
    flUpAngle: -0.70,
    flSnap: 22,
    flPunch: 260,          // extra impulse

    // Plunger
    plungerMax: 1500,
    plCharge: 1200,        // per second
    plMin: 120,

    lives: 3,
    ballSave: 1.2          // sec after launch
  };

  const cv = document.getElementById("cv");
  const boardEl = document.getElementById("board");
  const ctx = cv.getContext("2d");

  const elScore = document.getElementById("score");
  const elMult  = document.getElementById("mult");
  const elTarget= document.getElementById("target");
  const elSum   = document.getElementById("sum");
  const toast   = document.getElementById("toast");

  const over = document.getElementById("over");
  const overRestart = document.getElementById("overRestart");
  const overClose = document.getElementById("overClose");
  const resetBtn = document.getElementById("resetBtn");

  const zl = document.getElementById("zl");
  const zr = document.getElementById("zr");

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const hypot = (x,y)=>Math.sqrt(x*x+y*y);

  // ---- Rendering transform (table coords -> canvas pixels) ----
  let DPR = 1;
  let scale = 1;
  let offX = 0, offY = 0;
  let pxW = 0, pxH = 0;

  function resize(){
    const r = boardEl.getBoundingClientRect();
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    pxW = Math.floor(r.width * DPR);
    pxH = Math.floor(r.height * DPR);
    cv.width = pxW;
    cv.height = pxH;

    // Fit table into board while keeping aspect ratio
    const sx = pxW / CFG.tableW;
    const sy = pxH / CFG.tableH;
    scale = Math.min(sx, sy);

    offX = (pxW - CFG.tableW * scale) * 0.5;
    offY = (pxH - CFG.tableH * scale) * 0.5;

    // Important: reset transform (no cumulative scaling)
    ctx.setTransform(1,0,0,1,0,0);
  }
  window.addEventListener("resize", resize, {passive:true});
  resize();

  function toTableCoords(clientX, clientY){
    const rect = cv.getBoundingClientRect();
    const x = (clientX - rect.left) * DPR;
    const y = (clientY - rect.top) * DPR;
    const tx = (x - offX) / scale;
    const ty = (y - offY) / scale;
    return {x:tx, y:ty};
  }

  // ---- Simple audio ticks (optional, no assets) ----
  let audioCtx=null;
  let soundOn=true;
  function beep(freq=520, dur=0.07, gain=0.04){
    if(!soundOn) return;
    try{
      if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      const t0 = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type="sine";
      o.frequency.setValueAtTime(freq, t0);
      g.gain.setValueAtTime(gain, t0);
      g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
      o.connect(g); g.connect(audioCtx.destination);
      o.start(t0); o.stop(t0+dur);
    }catch(e){}
  }

  function showToast(txt){
    toast.textContent = txt;
    toast.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toast.classList.remove("show"), 520);
  }

  // ---- Table geometry ----
  let walls=[], slings=[], bumpers=[], sensors=[];

  function seg(x1,y1,x2,y2, kind="wall"){ return {x1,y1,x2,y2, kind}; }
  function circ(x,y,r, chip){ return {x,y,r, chip, glow:0}; }
  function sens(x,y,r, fn, cd){ return {x,y,r, fn, t:0, cd}; }

  function buildTable(){
    const W = CFG.tableW, H = CFG.tableH;
    walls=[]; slings=[]; bumpers=[]; sensors=[];

    const pad = 12;
    const left=pad, right=W-pad, top=pad, bot=H-pad;

    // drain gap
    const drainGap = 128;
    const mid = W/2;

    // Outer
    walls.push(
      seg(left, top, right, top),
      seg(left, top, left, bot-180),
      seg(right, top, right, bot-180),
      seg(left, bot-180, mid - drainGap/2, bot),
      seg(mid + drainGap/2, bot, right, bot-180),
    );

    // Plunger lane
    const plA = W*0.80, plB=W*0.92;
    walls.push(
      seg(plA, bot, plA, H*0.50),
      seg(plB, bot, plB, H*0.14),
      seg(W*0.20, H*0.14, plB, H*0.14)
    );

    // Mid ramps
    walls.push(
      seg(W*0.18, H*0.48, W*0.40, H*0.58),
      seg(W*0.82, H*0.48, W*0.60, H*0.58),
    );

    // Slings triangles
    slings.push(
      seg(W*0.20, H*0.70, W*0.34, H*0.80, "sling"),
      seg(W*0.34, H*0.80, W*0.24, H*0.86, "sling"),
      seg(W*0.24, H*0.86, W*0.20, H*0.70, "sling"),

      seg(W*0.80, H*0.70, W*0.66, H*0.80, "sling"),
      seg(W*0.66, H*0.80, W*0.76, H*0.86, "sling"),
      seg(W*0.76, H*0.86, W*0.80, H*0.70, "sling"),
    );

    // Bumpers
    bumpers.push(
      circ(W*0.42, H*0.22, 25, CFG.bumperChips[0]),
      circ(W*0.58, H*0.22, 25, CFG.bumperChips[1]),
      circ(W*0.50, H*0.33, 30, CFG.bumperChips[2]),
    );

    // Orbit sensor (oben rechts)
    sensors.push(sens(W*0.86, H*0.18, 14, () => {
      score += 250 * mult;
      addChip(5);
      showToast("Orbit +5");
      beep(640,0.08,0.05);
    }, 0.7));
  }
  buildTable();

  // ---- Game state ----
  let score=0, mult=1, lives=CFG.lives, sum=0, tIdx=0, target=CFG.targetCycle[tIdx];
  let gameOver=false;

  const ball = { x: CFG.tableW-25, y: CFG.tableH-50, vx:0, vy:0, inPlunger:true, saveT:0 };
  let plPower=0;

  const flL = { side:"L", px:120, py:CFG.tableH-60, len:CFG.flLen, ang:0, targ:0, av:0 };
  const flR = { side:"R", px:CFG.tableW-170, py:CFG.tableH-60, len:CFG.flLen, ang:0, targ:0, av:0 };

  function resetBall(){
    ball.x = CFG.tableW-25;
    ball.y = CFG.tableH-50;
    ball.vx = 0; ball.vy = 0;
    ball.inPlunger = true;
    ball.saveT = 0;
    plPower = 0;
  }

  function resetAll(){
    score=0; mult=1; lives=CFG.lives; sum=0; tIdx=0; target=CFG.targetCycle[tIdx];
    gameOver=false;
    over.style.display="none";
    resetBall();
    updateHUD();
    showToast("Start");
  }

  function updateHUD(){
    elScore.textContent = String(score);
    elMult.textContent = String(mult);
    elTarget.textContent = String(target);
    elSum.textContent = String(sum);
  }

  function addChip(v){
    sum += v;

    if(sum === target){
      score += CFG.jackpotBase * mult;
      mult = clamp(mult+1,1,CFG.multMax);
      sum = 0;
      tIdx = (tIdx+1) % CFG.targetCycle.length;
      target = CFG.targetCycle[tIdx];
      showToast("JACKPOT!");
      beep(760,0.09,0.06);
    } else if(sum > target){
      mult = clamp(mult-1,1,CFG.multMax);
      sum = CFG.softBust ? Math.max(0,target-1) : 0;
      showToast("Oops…");
      beep(220,0.08,0.05);
    }
    updateHUD();
  }

  // ---- Collision helpers ----
  function closestPoint(px,py, x1,y1,x2,y2){
    const dx=x2-x1, dy=y2-y1;
    const l2 = dx*dx+dy*dy || 1;
    let t = ((px-x1)*dx + (py-y1)*dy)/l2;
    t = clamp(t,0,1);
    return { x:x1+t*dx, y:y1+t*dy };
  }
  function reflect(nx,ny, rest){
    const dot = ball.vx*nx + ball.vy*ny;
    if(dot < 0){
      ball.vx = (ball.vx - 2*dot*nx) * rest;
      ball.vy = (ball.vy - 2*dot*ny) * rest;
    }
  }

  function collideSegment(s, rest, boost=1){
    const cp = closestPoint(ball.x,ball.y, s.x1,s.y1,s.x2,s.y2);
    const dx = ball.x - cp.x, dy = ball.y - cp.y;
    const dist = Math.sqrt(dx*dx+dy*dy) || 0.0001;
    const overlap = (CFG.ballR) - dist;
    if(overlap > 0){
      const nx = dx/dist, ny = dy/dist;
      ball.x += nx*(overlap+0.5);
      ball.y += ny*(overlap+0.5);
      reflect(nx,ny,rest);
      ball.vx *= boost; ball.vy *= boost;
      return true;
    }
    return false;
  }

  function collideCircle(c, rest){
    const dx=ball.x-c.x, dy=ball.y-c.y;
    const dist = Math.sqrt(dx*dx+dy*dy) || 0.0001;
    const minD = CFG.ballR + c.r;
    if(dist < minD){
      const nx = dx/dist, ny = dy/dist;
      const overlap = minD - dist;
      ball.x += nx*(overlap+0.5);
      ball.y += ny*(overlap+0.5);
      reflect(nx,ny,rest);
      // tiny kick outward (premium feel without exploding)
      ball.vx += nx*70;
      ball.vy += ny*70;
      return true;
    }
    return false;
  }

  // ---- Input ----
  let holdL=false, holdR=false;

  function bindHold(el, setFn){
    el.addEventListener("pointerdown", (e)=>{ e.preventDefault(); setFn(true); }, {passive:false});
    el.addEventListener("pointerup", (e)=>{ e.preventDefault(); setFn(false); }, {passive:false});
    el.addEventListener("pointercancel", (e)=>{ e.preventDefault(); setFn(false); }, {passive:false});
    el.addEventListener("pointerleave", (e)=>{ e.preventDefault(); setFn(false); }, {passive:false});
  }
  bindHold(zl, v=>holdL=v);
  bindHold(zr, v=>holdR=v);

  window.addEventListener("keydown", (e)=>{
    if(e.repeat) return;
    if(e.key==="ArrowLeft" || e.key==="a") holdL=true;
    if(e.key==="ArrowRight" || e.key==="l") holdR=true;
    if(e.key===" ") tryLaunch();
  });
  window.addEventListener("keyup", (e)=>{
    if(e.key==="ArrowLeft" || e.key==="a") holdL=false;
    if(e.key==="ArrowRight" || e.key==="l") holdR=false;
  });

  // Plunger logic: right hold charges ONLY when ball in plunger
  function tryLaunch(){
    if(!ball.inPlunger) return;
    if(plPower >= CFG.plMin){
      ball.inPlunger=false;
      ball.vx = (Math.random()-0.5)*18;
      ball.vy = -plPower;
      ball.saveT = CFG.ballSave;
      plPower = 0;
      beep(420,0.06,0.04);
    }
  }

  // ---- Flippers ----
  function flipperEndpoints(f){
    const x2 = f.px + Math.cos(f.ang)*f.len;
    const y2 = f.py + Math.sin(f.ang)*f.len;
    return {x1:f.px, y1:f.py, x2, y2};
  }

  function updateFlippers(dt){
    const restL = +CFG.flRestAngle;
    const upL   = CFG.flUpAngle;
    const restR = Math.PI - CFG.flRestAngle;
    const upR   = Math.PI - CFG.flUpAngle;

    // left
    flL.targ = holdL ? upL : restL;
    // right
    flR.targ = holdR ? upR : restR;

    const move = (f)=>{
      const prev = f.ang;
      f.ang += (f.targ - f.ang) * clamp(CFG.flSnap*dt,0,1);
      f.av = (f.ang - prev) / dt;
    };
    move(flL); move(flR);
  }

  // ---- Fixed timestep loop (stabil) ----
  let last = performance.now();
  let acc = 0;
  const STEP = 1/120;

  function physicsStep(dt){
    if(gameOver) return;

    updateFlippers(dt);

    // Plunger charge
    if(ball.inPlunger){
      // keep ball in lane
      ball.x = CFG.tableW - 25;
      ball.y = clamp(ball.y, CFG.tableH-90, CFG.tableH-50);

      if(holdR){
        plPower = clamp(plPower + CFG.plCharge*dt, 0, CFG.plungerMax);
      } else {
        if(plPower > 0) tryLaunch();
      }
      return;
    }

    // integrate
    ball.vy += CFG.gravity * dt;
    ball.x += ball.vx * dt;
    ball.y += ball.vy * dt;

    // damping
    ball.vx *= CFG.damping;
    ball.vy *= CFG.damping;

    // speed cap
    const sp = hypot(ball.vx,ball.vy);
    if(sp > CFG.maxSpeed){
      const s = CFG.maxSpeed/sp;
      ball.vx *= s; ball.vy *= s;
    }

    // collisions walls
    for(const w of walls) collideSegment(w, CFG.wallRest, 1);

    // slings add small boost
    for(const s of slings){
      if(collideSegment(s, CFG.slingRest, 1.02)){
        score += 25 * mult;
        beep(460,0.05,0.03);
        updateHUD();
      }
    }

    // flippers collide + punch on active press
    const fls = [flL, flR];
    for(const f of fls){
      const e = flipperEndpoints(f);
      const hit = collideSegment({x1:e.x1,y1:e.y1,x2:e.x2,y2:e.y2}, CFG.flipperRest, 1);
      if(hit){
        const pressing = (f.side==="L" && holdL) || (f.side==="R" && holdR);
        if(pressing){
          // punch away from flipper direction (controlled)
          ball.vx += Math.cos(f.ang) * CFG.flPunch;
          ball.vy += Math.sin(f.ang) * CFG.flPunch;
        }
        beep(420,0.04,0.025);
      }
    }

    // bumpers
    for(const b of bumpers){
      if(collideCircle(b, CFG.bumperRest)){
        b.glow = 1;
        score += 80 * mult;
        addChip(b.chip);
        beep(620,0.06,0.04);
      }
      b.glow = Math.max(0, b.glow - 3*dt);
    }

    // sensors
    for(const s of sensors){
      s.t = Math.max(0, s.t - dt);
      if(s.t>0) continue;
      const dx=ball.x-s.x, dy=ball.y-s.y;
      if(dx*dx+dy*dy <= (CFG.ballR+s.r)*(CFG.ballR+s.r)){
        s.t = s.cd;
        s.fn();
      }
    }

    // drain
    if(ball.saveT > 0) ball.saveT = Math.max(0, ball.saveT - dt);

    if(ball.y > CFG.tableH + 50){
      if(ball.saveT > 0){
        resetBall();
        showToast("Ball Save");
        return;
      }
      lives--;
      mult = 1;
      sum = 0;
      updateHUD();

      if(lives > 0){
        showToast("Ball verloren");
        resetBall();
      } else {
        gameOver = true;
        over.style.display="flex";
      }
    }
  }

  function draw(){
    // clear
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,pxW,pxH);

    // transform to table coords
    ctx.setTransform(scale,0,0,scale, offX, offY);

    // soft background wash
    const g = ctx.createLinearGradient(0,0,0,CFG.tableH);
    g.addColorStop(0,"rgba(74,124,145,0.10)");
    g.addColorStop(1,"rgba(74,124,145,0.00)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,CFG.tableW,CFG.tableH);

    // subtle grid
    ctx.save();
    ctx.globalAlpha = 0.06;
    ctx.strokeStyle = "rgba(45,42,38,1)";
    ctx.lineWidth = 1;
    for(let x=28;x<CFG.tableW;x+=28){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,CFG.tableH); ctx.stroke(); }
    for(let y=28;y<CFG.tableH;y+=28){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(CFG.tableW,y); ctx.stroke(); }
    ctx.restore();

    // walls
    ctx.strokeStyle="rgba(45,42,38,0.26)";
    ctx.lineWidth=6;
    ctx.lineCap="round";
    for(const w of walls){
      ctx.beginPath(); ctx.moveTo(w.x1,w.y1); ctx.lineTo(w.x2,w.y2); ctx.stroke();
    }

    // slings
    ctx.strokeStyle="rgba(74,124,145,0.30)";
    ctx.lineWidth=6;
    for(const s of slings){
      ctx.beginPath(); ctx.moveTo(s.x1,s.y1); ctx.lineTo(s.x2,s.y2); ctx.stroke();
    }

    // bumpers
    for(const b of bumpers){
      // glow ring
      ctx.save();
      ctx.globalAlpha = 0.10 + 0.20*b.glow;
      ctx.fillStyle = "rgba(74,124,145,1)";
      ctx.beginPath(); ctx.arc(b.x,b.y,b.r+10,0,Math.PI*2); ctx.fill();
      ctx.restore();

      // body
      ctx.fillStyle="rgba(255,255,255,0.92)";
      ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
      ctx.lineWidth=2;
      ctx.strokeStyle="rgba(45,42,38,0.22)";
      ctx.stroke();

      ctx.fillStyle="rgba(45,42,38,0.86)";
      ctx.font="900 14px Nunito";
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      ctx.fillText("+"+b.chip, b.x, b.y);
    }

    // sensors subtle
    ctx.save();
    ctx.globalAlpha=0.14;
    ctx.fillStyle="rgba(74,124,145,1)";
    for(const s of sensors){
      ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();

    // flippers
    drawFlipper(flL);
    drawFlipper(flR);

    // plunger lane hint
    ctx.save();
    ctx.globalAlpha=0.16;
    ctx.fillStyle="rgba(74,124,145,1)";
    ctx.fillRect(CFG.tableW*0.80, CFG.tableH*0.52, (CFG.tableW*0.92-CFG.tableW*0.80), CFG.tableH*0.38);
    ctx.restore();

    // plunger bar
    if(ball.inPlunger && plPower>0){
      const frac = clamp(plPower/CFG.plungerMax,0,1);
      ctx.save();
      ctx.globalAlpha=0.70;
      ctx.fillStyle="rgba(74,124,145,1)";
      const h = frac*210;
      ctx.fillRect(CFG.tableW-10, CFG.tableH-50-h, 6, h);
      ctx.restore();
    }

    // ball
    ctx.fillStyle="rgba(255,255,255,0.95)";
    ctx.beginPath(); ctx.arc(ball.x,ball.y,CFG.ballR,0,Math.PI*2); ctx.fill();
    ctx.lineWidth=2;
    ctx.strokeStyle="rgba(45,42,38,0.22)";
    ctx.stroke();

    // ball save halo
    if(!ball.inPlunger && ball.saveT>0){
      ctx.save();
      ctx.globalAlpha=0.12;
      ctx.strokeStyle="rgba(74,124,145,1)";
      ctx.lineWidth=6;
      ctx.beginPath(); ctx.arc(ball.x,ball.y,CFG.ballR+9,0,Math.PI*2); ctx.stroke();
      ctx.restore();
    }
  }

  function drawFlipper(f){
    const e = flipperEndpoints(f);
    ctx.lineCap="round";

    // base
    ctx.lineWidth = CFG.flWidth;
    ctx.strokeStyle="rgba(45,42,38,0.34)";
    ctx.beginPath(); ctx.moveTo(e.x1,e.y1); ctx.lineTo(e.x2,e.y2); ctx.stroke();

    // highlight
    ctx.lineWidth = Math.max(4, CFG.flWidth-6);
    ctx.strokeStyle="rgba(255,255,255,0.70)";
    ctx.beginPath(); ctx.moveTo(e.x1,e.y1); ctx.lineTo(e.x2,e.y2); ctx.stroke();
  }

  function loop(now){
    const dt = Math.min(0.05, (now-last)/1000);
    last = now;

    acc += dt;
    while(acc >= STEP){
      physicsStep(STEP);
      acc -= STEP;
    }
    draw();
    requestAnimationFrame(loop);
  }

  // UI actions
  resetBtn.addEventListener("click", resetAll);
  overRestart.addEventListener("click", resetAll);
  overClose.addEventListener("click", ()=>{ over.style.display="none"; });

  // prevent iOS scroll
  document.addEventListener("touchmove", (e)=>e.preventDefault(), {passive:false});

  // init
  resetAll();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
